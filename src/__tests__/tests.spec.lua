-- upstream: https://github.com/apollographql/graphql-tag/blob/v2.12.3/src/tests.ts
-- ROBLOX DEVIATION: swapping chai to jest
return function()
	local srcWorkspace = script.Parent.Parent
	local rootWorkspace = srcWorkspace.Parent
	local JestGlobals = require(rootWorkspace.Dev.JestGlobals)
	local jestExpect = JestGlobals.expect
	local LuauPolyfill = require(rootWorkspace.LuauPolyfill)

	local gql = require(srcWorkspace).gql
	local resetCaches = require(srcWorkspace).resetCaches
	local console, capturedWarns

	local function captureWarn(...)
		-- mimic `print`'s concatenation of var-args
		table.insert(capturedWarns, table.concat({ ... }, " "))
	end

	local function overrideWarn(fn: (...any) -> (), ...)
		local originalWarn = getfenv(fn).warn
		getfenv(fn).warn = captureWarn
		fn(...)
		getfenv(fn).warn = originalWarn
	end

	describe("gql", function()
		-- ROBLOX DEVIATION: no fragment support, test is irrelevant
		-- it("parses queries with weird substitutions", function()
		-- local obj = Object:create(nil)
		-- assert:equal( --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
		--   --[[ gql`{ field(input: "${obj.missing}") }` ]].kind, "Document")
		-- assert:equal( --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
		--   --[[ gql`{ field(input: "${null}") }` ]].kind, "Document")
		-- assert:equal( --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
		--   --[[ gql`{ field(input: "${0}") }` ]].kind, "Document")
		-- end)
		-- it("parses fragments with variable definitions", function()
		-- gql:enableExperimentalFragmentVariables()
		-- local parsed: any =  --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
		--   --[[ gql`fragment A ($arg: String!) on Type { testQuery }` ]]
		-- assert:equal(parsed.kind, "Document")
		-- assert:exists(parsed.definitions[1] --[[ ROBLOX adaptation: added 1 to array index ]].variableDefinitions)
		-- gql:disableExperimentalFragmentVariables()
		-- end)

		-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
		-- it("allows interpolation of documents generated by the webpack loader", function()
		-- local sameFragment = "fragment SomeFragmentName on SomeType { someField }"
		-- local jsSource = loader:call({cacheable = function(self) end}, sameFragment)
		-- ^^ should be converted to: local jsSource = loader({cacheable = function(self) end}, sameFragment)
		-- local module = {exports = Object:create(nil)}
		-- Function("module", jsSource)(module)
		-- local document =  --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
		--   --[[ gql`query { ...SomeFragmentName } ${module.exports}` ]]
		-- assert:equal(document.kind, "Document")
		-- assert:equal(document.definitions.length, 2)
		-- assert:equal(document.definitions[1] --[[ ROBLOX adaptation: added 1 to array index ]].kind, "OperationDefinition")
		-- assert:equal(document.definitions[2] --[[ ROBLOX adaptation: added 1 to array index ]].kind, "FragmentDefinition")
		-- end)

		-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
		-- it("parses queries through webpack loader", function()
		-- local jsSource = loader:call({cacheable = function(self) end}, "{ testQuery }")

		-- local module = {exports = Object:create(nil)}
		-- -- local function(module, jsSource)(module) end
		-- Function("module", jsSource)(module)
		-- jestExpect(module.exports.kind).toEqual("Document")
		-- end)

		-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
		-- it("parses single query through webpack loader", function()
		-- local jsSource = loader:call({cacheable = function(self) end}, [[

		--       query Q1 { testQuery }
		--     ]])

		-- local module = {exports = Object:create(nil)}
		-- Function("module", jsSource)(module)
		-- jestExpect(module.exports.kind).toEqual("Document")
		-- jestExpect(module.exports.Q1).to.equal(true)
		-- jestExpect(module.exports.Q1.kind).toEqual("Document")
		-- jestExpect(module.exports.Q1.definitions.length).toEqual(1)
		-- end)

		-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
		-- it("parses single query and exports as default", function()
		-- local jsSource = loader:call({cacheable = function(self) end}, [[

		--       query Q1 { testQuery }
		--     ]])

		-- local module = {exports = Object:create(nil)}
		-- Function("module", jsSource)(module)
		-- jestExpect(module.exports.definitions).toEqual(module.exports.Q1.definitions)
		-- end)

		-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
		-- it("parses multiple queries through webpack loader", function()
		-- local jsSource = loader:call({cacheable = function(self) end}, [[

		--       query Q1 { testQuery }
		--       query Q2 { testQuery2 }
		--     ]])
		-- local module = {exports = Object:create(nil)}
		-- Function("module", jsSource)(module)
		-- jestExpect(module.exports.Q1).to.equal(true)
		-- jestExpect(module.exports.Q2).to.equal(true)
		-- jestExpect(module.exports.Q1.kind).toEqual("Document")
		-- jestExpect(module.exports.Q2.kind).toEqual("Document")
		-- jestExpect(module.exports.Q1.definitions.length).toEqual(1)
		-- jestExpect(module.exports.Q2.definitions.length).toEqual(1)
		-- end)

		-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
		-- it("does not nest queries needlessly in named exports", function()
		-- local jsSource = loader:call({cacheable = function(self) end}, [[

		--       query Q1 { testQuery }
		--       query Q2 { testQuery2 }
		--       query Q3 { test Query3 }
		--     ]])

		-- local module = {exports = Object:create(nil)}
		-- Function("module", jsSource)(module)
		-- jestExpect(module.exports.Q2.Q1).to.equal(false)
		-- jestExpect(module.exports.Q3.Q1).to.equal(false)
		-- jestExpect(module.exports.Q3.Q2).to.equal(false)
		-- end)

		-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
		-- it("tracks fragment dependencies from multiple queries through webpack loader", function()
		-- local jsSource = loader:call({cacheable = function(self) end}, [[

		--       fragment F1 on F { testQuery }
		--       fragment F2 on F { testQuery2 }
		--       fragment F3 on F { testQuery3 }
		--       query Q1 { ...F1 }
		--       query Q2 { ...F2 }
		--       query Q3 {
		--         ...F1
		--         ...F2
		--       }
		--     ]])

		-- local module = {exports = Object:create(nil)}
		-- Function("module", jsSource)(module)
		-- jestExpect(module.exports.Q1).to.equal(true)
		-- jestExpect(exists(module.exports.Q2).to.equal(true))
		-- jestExpect(exists(module.exports.Q3).to.equal(true))
		-- local Q1 = module.exports.Q1.definitions
		-- local Q2 = module.exports.Q2.definitions
		-- local Q3 = module.exports.Q3.definitions
		-- assert:equal(Q1.length, 2)

		-- assert:equal(Q1[1] --[[ ROBLOX adaptation: added 1 to array index ]].name.value, "Q1")
		-- assert:equal(Q1[2] --[[ ROBLOX adaptation: added 1 to array index ]].name.value, "F1")
		-- assert:equal(Q2.length, 2)
		-- assert:equal(Q2[1] --[[ ROBLOX adaptation: added 1 to array index ]].name.value, "Q2")
		-- assert:equal(Q2[2] --[[ ROBLOX adaptation: added 1 to array index ]].name.value, "F2")
		-- assert:equal(Q3.length, 3)
		-- assert:equal(Q3[1] --[[ ROBLOX adaptation: added 1 to array index ]].name.value, "Q3")
		-- assert:equal(Q3[2] --[[ ROBLOX adaptation: added 1 to array index ]].name.value, "F1")
		-- assert:equal(Q3[3] --[[ ROBLOX adaptation: added 1 to array index ]].name.value, "F2")
		-- end)

		-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
		-- it("tracks fragment dependencies across nested fragments", function()
		-- local jsSource = loader:call({cacheable = function(self) end}, [[

		--       fragment F11 on F { testQuery }
		--       fragment F22 on F {
		--         ...F11
		--         testQuery2
		--       }
		--       fragment F33 on F {
		--         ...F22
		--         testQuery3
		--       }

		--       query Q1 {
		--         ...F33
		--       }

		--       query Q2 {
		--         id
		--       }
		--     ]])
		-- local module = {exports = Object:create(nil)}
		-- Function("module", jsSource)(module)
		-- jestExpect(module.exports.Q1).to.equal(true)
		-- jestExpect(module.exports.Q2).to.equal(true)
		-- local Q1 = module.exports.Q1.definitions
		-- local Q2 = module.exports.Q2.definitions

		-- assert:equal(Q1.length, 4)
		-- assert:equal(Q1[1] --[[ ROBLOX adaptation: added 1 to array index ]].name.value, "Q1")
		-- assert:equal(Q1[2] --[[ ROBLOX adaptation: added 1 to array index ]].name.value, "F33")
		-- assert:equal(Q1[3] --[[ ROBLOX adaptation: added 1 to array index ]].name.value, "F22")
		-- assert:equal(Q1[4] --[[ ROBLOX adaptation: added 1 to array index ]].name.value, "F11")
		-- assert:equal(Q2.length, 1)
		-- end)

		-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
		-- it("correctly imports other files through the webpack loader", function()
		-- local query = [[#import "./fragment_definition.graphql"
		--       query {
		--         author {
		--           ...authorDetails
		--         }
		--       }]]
		-- local jsSource = loader:call({cacheable = function(self) end}, query)
		-- local module = {exports = Object:create(nil)}
		-- local function require(path: string)
		-- expect(path).toEqual("./fragment_definition.graphql")
		-- return  --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
		--   --[[ gql`
		--         fragment authorDetails on Author {
		--           firstName
		--           lastName
		--         }` ]]
		-- end
		-- Function("module,require", jsSource)(module, require)
		-- assert:equal(module.exports.kind, "Document")
		-- local definitions = module.exports.definitions
		-- assert:equal(definitions.length, 2)
		-- assert:equal(definitions[1] --[[ ROBLOX adaptation: added 1 to array index ]].kind, "OperationDefinition")
		-- assert:equal(definitions[2] --[[ ROBLOX adaptation: added 1 to array index ]].kind, "FragmentDefinition")
		-- end)

		-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
		-- it("tracks fragment dependencies across fragments loaded via the webpack loader", function()
		-- local query = [[#import "./fragment_definition.graphql"
		--       fragment F111 on F {
		--         ...F222
		--       }

		--       query Q1 {
		--         ...F111
		--       }

		--       query Q2 {
		--         a
		--       }
		--       ]]
		-- local jsSource = loader:call({cacheable = function(self) end}, query)
		-- local module = {exports = Object:create(nil)}
		-- local function require(path: string)
		-- assert:equal(path, "./fragment_definition.graphql")
		-- return  --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
		--   --[[ gql`
		--         fragment F222 on F {
		--           f1
		--           f2
		--         }` ]]
		-- end

		-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
		-- Function("module,require", jsSource)(module, require)
		-- assert:exists(module.exports.Q1)
		-- assert:exists(module.exports.Q2)
		-- local Q1 = module.exports.Q1.definitions
		-- local Q2 = module.exports.Q2.definitions
		-- assert:equal(Q1.length, 3)
		-- assert:equal(Q1[1] --[[ ROBLOX adaptation: added 1 to array index ]].name.value, "Q1")
		-- assert:equal(Q1[2] --[[ ROBLOX adaptation: added 1 to array index ]].name.value, "F111")
		-- assert:equal(Q1[3] --[[ ROBLOX adaptation: added 1 to array index ]].name.value, "F222")
		-- assert:equal(Q2.length, 1)
		-- end)

		-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
		-- it("does not complain when presented with normal comments", function(done)
		--   -- toThrow
		-- assert:doesNotThrow(function()
		-- local query = [[#normal comment
		--         query {
		--           author {
		--             ...authorDetails
		--           }
		--         }]]
		-- local jsSource = loader:call({cacheable = function(self) end}, query)
		-- local module = {exports = Object:create(nil)}
		-- Function("module", jsSource)(module)
		-- jestExpect(module.exports.kind).toEqual("Document")
		-- done()
		-- end)
		-- end)

		-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
		-- it("ignores duplicate fragments from second-level imports when using the webpack loader", function()
		--   local function load(require: any, query: string): any
		--   local jsSource = loader:call({cacheable = function(self) end}, query)
		--   local module = {exports = Object:create(nil)}
		--   Function("require,module", jsSource)(require, module)
		--   return module.exports
		--   end
		--   local function test_require(path: string)
		--     --[[ ROBLOX TODO: Unhandled node for type: SwitchStatement ]]
		--     --[[ switch (path) {
		--           case './friends.graphql':
		--             return load(test_require, [
		--               '#import "./person.graphql"',
		--               'fragment friends on Hero { friends { ...person } }',
		--             ].join('\n'));
		--           case './enemies.graphql':
		--             return load(test_require, [
		--               '#import "./person.graphql"',
		--               'fragment enemies on Hero { enemies { ...person } }',
		--             ].join('\n'));
		--           case './person.graphql':
		--             return load(test_require, 'fragment person on Person { name }\n');
		--           default:
		--             return null;
		--           } ]]
		--     --[[ ROBLOX TODO: Unhandled node for type: EmptyStatement ]]
		--     --[[ ; ]]
		--   end
		--   local result =  --[[ ROBLOX TODO: Unhandled node for type: TSNonNullExpression ]]
		--     --[[ load(test_require, [
		--           '#import "./friends.graphql"',
		--           '#import "./enemies.graphql"',
		--           'query { hero { ...friends ...enemies } }',
		--         ].join('\n'))! ]]
		--   assert:equal(result.kind, "Document")
		--   assert:equal(result.definitions.length, 4, "after deduplication, only 4 fragments should remain")
		--   assert:equal(result.definitions[1] --[[ ROBLOX adaptation: added 1 to array index ]].kind, "OperationDefinition")
		--   local fragments =  --[[ ROBLOX TODO: Unhandled node for type: TSAsExpression ]]
		--     --[[ result.definitions.slice(1) as FragmentDefinitionNode[] ]]
		--   assert(fragments:every(function(fragment)
		--   return fragment.kind == "FragmentDefinition"
		--   end))
		--   assert(fragments:some(function(fragment)
		--   return fragment.name.value == "friends"
		--   end))
		--   assert(fragments:some(function(fragment)
		--   return fragment.name.value == "enemies"
		--   end))
		--   assert(fragments:some(function(fragment)
		--   return fragment.name.value == "person"
		--   end))
		--   end)

		it("parses queries", function()
			jestExpect(gql([[{ testQuery }]]).kind).toEqual("Document")
		end)

		it("parses queries when called as a function", function()
			jestExpect(gql("{ testQuery }").kind).toEqual("Document")
		end)

		it("returns the same object for the same query", function()
			jestExpect(gql("{ sameQuery }")).toEqual(gql("{ sameQuery }"))
		end)

		it("returns the same object for the same query, even with whitespace differences", function()
			jestExpect(gql("{ sameQuery }")).toEqual(gql("{ sameQuery,   }"))
		end)

		-- ROBLOX DEVIATION: no fragment support, vartiable is irrelevant
		-- local _fragmentAst = gql([[
		--   fragment UserFragment on User {
		--     firstName
		--     lastName
		--   }]])

		it("returns the same object for the same fragment", function()
			jestExpect(gql("fragment same on Same { sameQuery }")).toEqual(gql("fragment same on Same { sameQuery }"))
		end)

		-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
		-- it("returns the same object for the same document with substitution", function()
		-- 	-- assert:isTrue( --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
		-- 	--   --[[ gql`{ ...UserFragment } ${fragmentAst}` ]] ==  --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
		-- 	--   --[[ gql`{ ...UserFragment } ${fragmentAst}` ]])
		-- end)

		-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
		-- it("can reference a fragment that references as fragment", function()
		-- local secondFragmentAst =  --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
		--   --[[ gql`
		--       fragment SecondUserFragment on User {
		--         ...UserFragment
		--       }
		--       ${fragmentAst}
		--     ` ]]
		-- local ast =  --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
		--   --[[ gql`
		--       {
		--         user(id: 5) {
		--           ...SecondUserFragment
		--         }
		--       }
		--       ${secondFragmentAst}
		--     ` ]]
		-- assert:deepEqual(ast,  --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
		--   --[[ gql`
		--       {
		--         user(id: 5) {
		--           ...SecondUserFragment
		--         }
		--       }
		--       fragment SecondUserFragment on User {
		--         ...UserFragment
		--       }
		--       fragment UserFragment on User {
		--         firstName
		--         lastName
		--       }
		--     ` ]])
		-- end)

		describe("fragment warnings", function()
			beforeEach(function()
				resetCaches()
				capturedWarns = {}
				console = LuauPolyfill.console
			end)

			it("warns if you use the same fragment name for different fragments", function()
				overrideWarn(console.warn, "You are using the same fragment name for different fragments")
				local frag1 = gql([[fragment TestSame on Bar { fieldOne }]])
				local frag2 = gql([[fragment TestSame on Bar { fieldTwo }]])
				jestExpect(frag1 == frag2).toBe(false)
				jestExpect(#capturedWarns).toEqual(1)
			end)

			it("does not warn if you use the same fragment name for the same fragment", function()
				local frag1 = gql([[fragment TestDifferent on Bar { fieldOne }]])
				local frag2 = gql([[fragment TestDifferent on Bar { fieldOne }]])
				jestExpect(frag1 == frag2).toBe(true)
				jestExpect(#capturedWarns).toEqual(0)
			end)

			-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
			-- it("does not warn if you use the same embedded fragment in two different queries", function()
			-- 	-- local frag1 =  --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
			-- 	--   --[[ gql`fragment TestEmbedded on Bar { field }` ]]
			-- 	-- local query1 =  --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
			-- 	--   --[[ gql`{ bar { fieldOne ...TestEmbedded } } ${frag1}` ]]
			-- 	-- local query2 =  --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
			-- 	--   --[[ gql`{ bar { fieldTwo ...TestEmbedded } } ${frag1}` ]]
			-- 	-- assert:isFalse(query1 == query2)
			-- 	jestExpect(#warnings).toEqual(0)
			-- end)

			-- it("does not warn if you use the same fragment name for embedded and non-embedded fragments", function()
			-- 	-- local frag1 =  --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
			-- 	--   --[[ gql`fragment TestEmbeddedTwo on Bar { field }` ]]
			-- 	--   --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
			-- 	--   --[[ gql`{ bar { ...TestEmbedded } } ${frag1}` ]]
			-- 	--   --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
			-- 	--   --[[ gql`{ bar { ...TestEmbedded } } fragment TestEmbeddedTwo on Bar { field }` ]]
			-- 	assert:equal(warnings.length, 0)
			-- end)
		end)

		-- describe("unique fragments", function()
		-- 	beforeEach(function()
		-- 		gql:resetCaches()
		-- 	end)

		-- ROBLOX DEVIATION: no fragment or webpack support, test is irrelevant
		-- 	it("strips duplicate fragments from the document", function()
		-- 		-- local frag1 =  --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
		-- 		--   --[[ gql`fragment TestDuplicate on Bar { field }` ]]
		-- 		-- local query1 =  --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
		-- 		--   --[[ gql`{ bar { fieldOne ...TestDuplicate } } ${frag1} ${frag1}` ]]
		-- 		-- local query2 =  --[[ ROBLOX TODO: Unhandled node for type: TaggedTemplateExpression ]]
		-- 		--   --[[ gql`{ bar { fieldOne ...TestDuplicate } } ${frag1}` ]]
		-- 		assert:equal(query1.definitions.length, 2)
		-- 		assert:equal(
		-- 			query1.definitions[2] --[[ ROBLOX adaptation: added 1 to array index ]].kind,
		-- 			"FragmentDefinition"
		-- 		)
		-- 		assert:deepEqual(query1.definitions, query2.definitions)
		-- 	end)
		-- end)
	end)
end
